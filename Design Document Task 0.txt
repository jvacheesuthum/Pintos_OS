            +----------------------+
            |        OS 211        |
            |  TASK 0: ALARMCLOCK  |
            |    DESIGN DOCUMENT   |
            +----------------------+
                   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Ho Law <hcl114@ic.ac.uk>
Vasin Wongrassamee <vw214@ic.ac.uk>
Jiranart Vacheesuthum <jv1814@ic.ac.uk>
Kam Chiu <klc114@ic.ac.uk>


---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

None.

                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

>> A1: (2 marks) 
>> Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

static struct list sleep_list;
struct sleeping_thread
  {
    struct list_elem elem; //Element of sleeping_list
    struct semaphore sema; //Up when alarm_ticks <= 0
    int64_t alarm_ticks; //ticks left until running
  };

A struct representing a waiting thread that is stored in sleep_list. The thread waits until the semaphore is 'up' caused by the alarm_ticks.


---- ALGORITHMS ----

>> A2: (2 marks)
>> Briefly describe what happens in a call to timer_sleep(),
>> including the actions performed by the timer interrupt handler 
>> on each timer tick.

timer_sleep initializes a 'struct sleeping_thread' along with the elements inside it. The semaphore is initialized to zero and the thread is inserted to the back of sleep_list. The semaphore is 'down'ed causing the thread to wait.
timer_interrupt goes through sleep_list and decrement alarm_ticks of each thread. If alarm_ticks is no longer positive, the semaphore of that thread is 'up'ed and removed from sleep_list.

>> A3: (2 marks)
>> What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

Instead of calling timer_elapsed(start) and compare it with number of ticks so far in every call to timer_sleep, we decrement alarm_ticks in struct sleeping_thread for each interrupt called and "up" the semaphore in sleeping_thread. 

---- SYNCHRONIZATION ----

>> A4: (1 mark)
>> How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

timer_sleep() initializes a new struct every time it is called and it does not use any static variable apart from sleep_list. The order in which the 'struct sleeping_thread' is inserted into the list does not matter so multiple thread calls would not affect one another. Checking if a thread should 'wake up' also happens in timer_interrupt() and other threads would not be able to affect the list during timer_interrupt().

>> A5: (1 mark)
>> How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

The alarm_ticks only depends on the input for timer_sleep() so a a timer interrupt will not affect it. Checking if a thread should 'wake up' is also done in timer_interrupt after thread_tick() so similar to above, other process would not affect a thread calling timer_sleep().

---- RATIONALE ----

>> A6: (2 marks)
>> Why did you choose this design?  In what ways is it superior to
>> another design you considered?

We considered putting the semaphore and ticks into the 'struct thread', and having a list of pointers to these threads. However, storing the semaphore and ticks in the timer can reduce the size of the 'struct thread'. This could prevent the possibility of the 'struct thread' to grow too big.
